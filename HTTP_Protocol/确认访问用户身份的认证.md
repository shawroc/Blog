# 确认访问用户身份的认证

---
绝大多数内容引自《图解HTTP》
---

某些Web页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是认证功能。

## 何为认证

计算机本身无法判断坐在显示器前的使用者的身份。
进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清楚究竟是谁在访问服务器，就得让对方的客户端自报家门。

可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这点却无从谈起。为确认ueno本人是否真的具有访问系统的权限，就需要核对“登陆者本人才知道的信息”、“登陆者本人才会有的信息”。

核对的信息通畅是指以下这些。

- 密码： 只有本人才会知道的字符串信息。
- 动态令牌：仅限本人持有的设备内显示的一次性密码。
- 数字证书：仅限本人（终端）持有的信息。
- 生物认证：指纹和虹膜等本人的生理信息。
- IC卡等：仅限本人持有的信息。

但是，即便对方是假冒的用户，只要能通过用户验证，那么计算机就会默认是出自本人的行为。因此，掌握机密信息的密码决不能让他人得到，更不能轻易地就被破解出来。

HTTP使用的认证方式

HTTP/1.1 使用的认证方式如下所示。

- BASIC认证（基本认证）
- DIGEST 认证（摘要认证）
- SSL客户端认证
- FormBase 认证（基于表单认证）

此外，还有Windows统一认证（Keberos 认证、NTLM认证）。


## BASIC认证

BASIC认证（基本认证）是从HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行的认证方式。

步骤1： 当请求的资源需要BASIC 认证时，服务器会随状态码401 Authorization Required，返回带 WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）。

步骤2：接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号（：）连接后，再经过Base64编码处理。

假设用户ID为gurst，密码是guest，连接起来就会形成guest:guest这样的字符串。然后经过Base64编码，最后的结果就是 Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段Authorization后，发送请求。

当用户代理为浏览器时，用户仅需输入用户ID和密码即可，之后，浏览器会自动完成到Base64编码的转换工作。

步骤3： 接收到包含首部字段Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。

BASIC 认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。

另外，除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。

BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它不常用。

## DIGEST 认证

为弥补BASIC认证存在的弱点，从HTTP/1.1 起就有了DIGEST认证。DIGEST认证同样使用质询/响应的方式（challenge/response)，但不会像BASIC认证那样直接发送明文密码。

所谓质询响应是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。

因为发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起BASIC认证，密码泄露的可能性就降低了。

DIGEST 认证的认证步骤

步骤1： 请求需认证的资源时，服务器会随着状态码401 Authorization Required，返回带WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。

首部字段WWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。

nonce 是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。

步骤2：接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息。

首部字段Authorization 内必须包含username、realm、nonce、uri和response的字段信息。其中，realm和nonce就是之前从服务器接收到响应中的字段。

username 是 realm 限定范围内可进行认证的用户名。

uri（digest-uri）即 Request-URI的值，但考虑到经代理转发后 Request-URI的值可能会被修改，因此事先会复制一份副本保存在uri内。

response 也可叫做 Request-Digest，存放经过MD5 运算后的密码字符串，形成响应码。

响应中其他的实体可以wikiia请求首部的Authorization。另外，有关 Request-Digest 的计算规则较复杂。


步骤3：接收到包含首部字段Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI 资源的响应。

并且这时会在首部字段Authentication-Info 写入一些认证成功的相关信息。

DIGEST 认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。

DIGEST 认证和 BASIC认证一样，使用上不那么便捷灵活，且仍达不到多数Web网站对高度安全等级的追求标准。因此它的适用范围也有所受限。

## SSL客户端认证

从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证时本人的行为。但如果用户ID和密码被盗，就很有可能被第三者冒充。利用SSL客户端认证则可以避免该情况的发生。

SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来值得信任的客户端。

**SSL 客户端认证的认证步骤**

为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

步骤1： 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。

步骤2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate发送给服务器。

步骤3： 服务器验证客户端证书，验证通过后，方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。

### SSL客户端认证采用双因素认证

在多数情况下，SSL客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证(Two-factor authentication)来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素， 还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。

换言之，第一个认证因素的SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确认这是用户本人的行为。

通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。

### SSL 客户端认证必要的费用

使用SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。

这里提到的费用是指，从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营所产生的费用。

每个认证机构颁发给客户端证书的费用不尽相同，平摊到一张证书上，一年约几十到几百。服务器运行者也可以自己搭建认证机构，但要维持安全运行就会产生相应的费用。

### 基于表单认证

基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登陆信息（Credential），按登陆信息的验证结果认证。

根据Web 应用程序的实际安装，提供的用户界面及认证方式也各不相同。

多数情况下，输入已事先登陆的用户ID（通常是任意字符串或邮件地址）和密码等登陆信息后，发送给Web应用程序，基于认证结果来决定认证是否成功。

#### 认证多半为基于表单认证

由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。

比如SSH 和 FTP 协议，服务器与客户端之间的认证时合乎标准规范的，并且满足了最基本的功能需求上的安全使用级别，因此这些协议可以拿来直接使用。但是对于Web网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由Web应用程序各自实现基于表单的认证方式。

不具备共同标准规范的表单认证，在每个Web网站上都会有各不相同的实现方式。如果是全面考虑过安全性能而实现的表单认证，那么就能具备高度的安全等级。但在表单认证的实现中存在问题的Web网站也是屡见不鲜。

#### Session 管理及 Cookie应用

基于表单认证的标准规范尚未有定论，一般会使用Cookie 来管理 Session（会话）。

基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登陆过的信息做匹配来进行认证的。

但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此当用户下一次继续访问，无法区分。

于是会使用 Cookie 管理 Session，以弥补HTTP协议中不存在的状态管理功能。

步骤1： 客户端把用户ID和密码等登陆信息放入报文的实体部分，通常是以POST方法把请求发送还给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。

步骤2：服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登陆信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。

向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID（如 PHPSESSID=028a8c...）。

你可以把Session ID想象成一种用以区分不同用户的等位号。

**然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。**

步骤3： 客户端接收到从服务器发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。

除了以上介绍的应用实例，还有应用其他不同方法的案列。

另外，不仅基于表单认证的登良路信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登陆信息等也没有标准化。

通常，一种安全的保存方法是，先利用给密码加盐的方式增加额外信息，再使用散列函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄漏的风险。

**salt 加盐其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接生成散列值。当两个用户使用了同一个密码时，由于随机生成的salt值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解。**