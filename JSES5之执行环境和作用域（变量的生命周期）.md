---
前言：最近在细读Javascript高级程序设计，对于我而言，中文版，书中很多地方一笔带过，所以用自己所理解的，尝试细致解读下。如有纰漏或错误，会非常感谢您的指出。文中绝大部分内容引用自《JavaScript高级程序设计第三版》。

---

## 执行环境（execution context）

**执行环境（execution context，为了简单起见，有时也成为环境）是JavaScript中最为重要的一个概念。**

执行环境，定义了变量或函数有权访问其他数据，且决定了它们各自的行为。

**每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。**

虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

**全局执行环境时最外围的一个执行环境。**

根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。

**在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。**

**（变量的生命周期），某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁）**

**全局执行环境直到应用程序退出——例如关闭网页或浏览器时才会被销毁。**

**每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。**


## 作用域链（scope chain）

**当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。**
**作用域链的用途，是保证对执行环境，有权访问的所有变量和函数的有序访问。**

**作用域链的前端，始终都是当前执行的代码所在环境的变量对象。（也可以理解为“就近原则”）。**

如果这个环境是函数，则将其**活动对象（activation object）**作为变量对象。

**函数执行环境中的活动对象在最开始时，只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）作为变量对象。**

作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样，一直延续到全局执行环境。

**全局执行环境的变量对象，始终是作用域链中的最后一个对象。**

**标识符解析是沿着作用域链一级一级地搜索标识标识符的过程。**
**搜索过程始终从作用域链的前端开始，然后逐级向后回溯，直至找到标识符为止（如果找不到标识符，通过会导致错误发生）。**

```

var color = "blue";

function changeColor() {
    if(color === "blue") {
        color = "red";
    } else {
        color = "blue";
    }
}

changeColor();

console.log("Color is now " + color); // "color is now red"

```

在这个简单的例子中，函数changeColor()的作用域链包含两个对象： 

它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。

**可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。**


此外，在局部作用中定义的变量可以在局部环境中与全局变量互换使用。

```
var color = "blue";

function changeColor() {
    var anotherColor = "red";

    function swapColors(){

        //这里可以访问color、anotherColor和tempColor
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
    }

    //这里可以访问color和anotherColor，但不能访问tempColor
    swapColors();
}

//这里只能访问color
changeColor();

```

以上代码，涉及3个执行环境：

- 全局环境（在web浏览器中就是window）
- 函数changeColor()的局部环境
- 函数swapColors()的局部局部

全局环境中有一个变量color和一个函数changeColor()。changeColor()的局部环境中有一个名为anotherColor的变量和一个名为swapColors()的函数，但它也可以访问全局环境中的变量color。swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。

无论全局环境还是changeColor()的局部环境都无权访问tempColor。

然而，在swapColors()内部，则可以访问其他两个环境中的变量，因为那两个环境是它的父执行环境。

```
      
 window, color, changeColor()
            |
    anotherColor, swapColors()
                    |
                tempColor

```

**内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。**

**这些环境之间的联系是线性、有次序的。**

**每个环境都可以向上搜索作用域链，以查询变量和函数名。但是，任何环境都不能通过向下搜索作用域链而进入另一个执行环境。**

**函数参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同。**


## 没有块级作用域（ES5中没有）

JavaScript没有块级作用域经常会导致理解上的困惑。
在其他类C的语言中，由花括号封闭的代码块都有自己的作用域（如果用ECMAScript的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量。

```

if(true) {
    var color = "blue";
}

console.log(color); //"blue"

```

这里是在有一个if语句中定义了变量color。
如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。
但在JavaScript中，if语句中的变量声明会将变量添加当前的执行环境（在这里是全局环境window）中。

在使用for语句时尤其要牢记这一差异。

```

for(var i = 0; i < 10; i++) {
    console.log(i); // 0,1,2,3,4,5,6,7,8,9
}

/*
//等价于
var i;

for(i = 0; i < 10; i++) {
    console.log(i);
}

*/

console.log(i); //10

```

对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循坏的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环结束之后，也依旧会存在于循坏外部的执行环境中。

### 声明变量

**使用var声明的变量会自动被添加到最接近的环境中，在函数内部，最接近的环境就是函数的局部环境。**

如果初始化变量时没有使用var声明，该变量会自动被添加到全局作用域。

```

function add(num1, num2) {
    var sum = num1 + num2;
    return sum;
}

var result = add(10,20); //30
console.log(sum); //sum is not defined
```

以上代码中的函数add()定义了一个名为sum的局部变量，该变量包含加法操作的结果。
虽然结果值从函数中返回了，但变量sum在函数外部是访问不到的。
如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到。

```

function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}

var result = add(10,20); // 30
console.log(sum); 30

```

在这个例子中的变量sum在被初始化赋值时没有使用var关键字。
于是，当调用完add()之后，添加到全局环境中的变量sum将继续存在。
即使函数已经执行完毕，后面的代码依旧可以访问它。

**在编写JavaScript代码的过程中，不声明而直接初始化变量时一个常见的错误，这样会导致一些不可预估的意外。养成良好的习惯，在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。**

### 2.查询标识符

**当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。**

如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。

如果在局部环境中没有找到该变量，则继续沿作用域向上搜索。

搜索过程将一直追溯到全局环境的变量对象。

如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

```
var color = "blue";

function getColor() {
    return color;
}

console.log(getColor()); // "blue"

/*
window = {
    color,
    getColor = function() {
        return color;
    }
}
*/
```

调用本例中的函数getColor()时会引用变量color。

为了确定变量color的值，将开始一个两步的搜索过程。

- 首先，在getColor()的局部环境中搜索变量对象，查找其中是否包含一个名为color的标识符。
- 然后，没有找到，对不？那就到外面的环境中找，在全局作用域中找到名为color的标识符。

搜索到了定义这个变量的变量对象，搜索过程宣告结束。


**在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止（找到了，我就不找了），不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。**

```
var color = "blue";

function getColor() {
    var color = "red";
    return color;
}

console.log(getColor()); //"red"

```

修改后的代码在getColor()函数中声明了一个名为color的局部变量。
调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。
搜索过程，首先从局部环境中开始，而且在这里发现了一个名为color的变量，其值为“red”。
变量已经在函数的局部环境中找到了，所以搜索停止，return语句就使用这个局部变量，并为函数返回“red”。

如果不使用window.color都无法访问全局color变量。

**变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕可以忽略不记。** 

但是，我们还是要养成良好的编程习惯。虽说，这个差别可以忽略不记。
