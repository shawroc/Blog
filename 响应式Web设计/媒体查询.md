# 媒体查询

---
绝大部分引用自《响应式Web设计 HTML5和CSS3实战（第2版）
---

CSS规范分成很多模块，媒体查询（3级）只是其中一个模块。
利用媒体查询，可以根据设备的能力应用特定的CSS样式。比如，可以根据视口宽度、屏幕宽高比和朝向（水平还是垂直）等，只用几行CSS代码就改变内容的显示方式。

媒体查询得到了广泛实现。除了古老的IE（8及以下版本），几乎所有浏览器都支持它。
一句话，没理由不用它！

```
W3C制定规范要走一个批准流程。
如果有空，可以读读他们的官方流程文档：https://www.w3.org/2005/10/Process-20051014/tr。

简单来说，所有规范都从WD（Working Draft，工作草案）开始，然后是CR（Candidate Recommendation，候选推荐），接着是PR（Proposed Recommendation，建议推荐），几年后才能成为W3C REC(Recommendation，推荐标准)。

处于较成熟阶段的模块，通常使用起来也比较安全。
比如，CSS Transforms Module Level 3(http://www.w3.org/TR/css3-3d-transforms)在2009年3月就进入了WD阶段，但浏览器对它的支持度比处于CR阶段的媒体查询等模块差得多。

## 为什么响应式Web设计需要媒体查询

CSS3媒体查询可以让我们针对特定的设备能力或条件为网页应用特定的CSS样式。
翻开W3C的CSS3媒体查询模块的规范（https://www.w3.org/TR/css3-mediaqueries/)，可以看到官方给媒体查询下的定义：

```
“媒体查询包含媒体类型和零个或多个检测媒体特性的表达式。width、height和color都是可用于媒体查询的特性。使用媒体查询，可以不必修改内容本身，而让网页适配不同的设备。”
```

**如果没有媒体查询，光用CSS是无法大大修改网页外观的。这个模块让我们可以提前编写出适应很多不可预测因素的CSS规则，比如屏幕方向水平或垂直、视口或大或小，等等。**

弹性布局虽然可以让设计适应较多场景，也包括某些尺寸的屏幕，但有时候确实不够用，因为我们还需要对布局进行更细致的调整。媒体处查询让这一切成为可能，它就相当于CSS中基本的条件逻辑。

### CSS中基本的条件逻辑

真正的编程语言都有相应的语法构造处理一个或多个条件分支。这时候通常指的是条件逻辑，比如if/else语句。

如果提到编程你就心塞，大可不必！

这里要讲的只一个非常简单的概念。日常生活中，你可能会在朋友排队买咖啡时这么跟他说：“如果他们有三种巧克力松饼，给我买一份；如果没有，就给我买一封胡萝卜蛋糕。”这就是有两种可能结果的条件语句。

在协作本书时，CSS并不支持真正的条件逻辑或可编程特性。循环、函数、迭代和复杂的数学计算仍然只可能在CSS预处理其中看到（我可曾提过一本不错的专门将Sass
预处理器的书——《Sass和Compass设计师指南》？）。

不过，媒体查询确实具有在CSS中实现条件逻辑的能力。使用媒体查询，其中的样式只在某些条件具备的情况下才会被应用。

```
可编程的方式会有的

CSS预处理器的流行已经引起CSS规范编写者的注意。
目前已经有了一个关于CSS变量的WD：https://www.w3.org/TR/css-variables/。

不过，现在只有Firefox支持这个建议，因此还不具备普遍意义。

```

## 媒体查询的语法

说了那么多，媒体查询的语法是什么样的，还有更重要的，媒体查询怎么起作用。

在任何CSS文件的最后输入以下代码，然后打开引用该CSS文件的网页看看效果。

```

body {
    background-color: grey;
}

@media screen and (min-width: 320px) {
    body {
        background-color: green;
    }
}

@media screen and (min-width: 550px) {
    body {
        background-color: yellow;
    }
}

@media screen and (min-width:  768px) {
    body {
        background-color: orange;
    }
}

@media screen and (min-width: 960px) {
    body {
        background-color: red;
    }
}
```

好了，在浏览器中打开网页，缩放窗口并看看效果。页面的背景颜色会随着当前视口大小的变化而变化。稍后，我们会介绍这些语法如何起作用。但首先，关键是得知道如何以及在哪里可以使用媒体查询。


**在link标签中使用媒体查询**

从CSS2开始接触CSS的读者都知道，可以在\<link>标签的media属性中指定设备类型(screen或print)， 为不同设备应用哪个样式表。

```
<link rel="stylesheet" type="text/css" media="screen" href="screenstyles.css">
```

媒体查询更近一步，不仅可以指定设备类型，还能指定设备的能力和特性。
可以将其想象为对浏览器的询问。

如果浏览器回答“是”，那么就会应用对应的样式表。如果浏览器回答“否”就不会应用。

除了问浏览器：”你是在有屏幕的设备上吗？”（CSS2里只能如此），媒体查询可以问更多细节，比如可以问：“你是在有屏幕的设备上，而且设备是垂直朝向的吗？”

```
<link rel="sytlesheet" type="text/css" href="portrait-screen.css" media="screen and (orientation: portrait)">
```

首先，媒体查询表达式询问了设备的类型（是屏幕设备吗？），然后又询问特性（你的屏幕时垂直方向吗？）。显然，样式表portrait-screen.css会应用给任何有屏幕且屏幕方向垂直的沈北，而不符合这两个条件的设备则不会获得其样式。如果在媒体查询表达式的开头添加一个not，就可以把询问的条件反过来。

比如，以下代码的结果与前面的例子相反，只会将样式表应用给垂直朝向的非屏幕设备。

```
<link rel="stylesheet" type="text/css" href="portrait-screen.css" media="not screen and (orientation: portrait)"/>
```

## 组合使用媒体查询

可以将多个媒体查询串在一起。比如，在前面示例的基础上，可以进一步限制只把样式表应用给视口大于800像素的设备：

```
<link rel="stylesheet" type="text/css" href="portrait-screen.css" media="screen and (orientation: portrait) and (min-width: 800px), projection"/>
```

此外，可以组合多个媒体查询。只要其中任何一个媒体查询表达式为真，就会应用样式；如果没有一个为真，则样式表没用。

这里有两点需要强调一下。

首先，逗号分隔每个媒体查询表达式。
其次，在projection（投影机）之后没有任何特性/值对。

这样省略特定的特性，表示适用于具备任何特性的该媒体类型。
在这里，表示可以适用于任何投影机。

```
没错，任何CSS长度单位可以用来指定媒体查询的条件。像素（px）是最常用的，而em或rem也都可以用。假设你想在800像素处设置断点，但又想用em单位，可以用800除以16，就是50em。
```

### @import 与媒体查询

可以在使用@import导入CSS时使用媒体查询，有条件地向当前样式表中加载其他样式表。

比如，以下diamante会导入样式表phone.css，但条件是必须是屏幕设备，而且视口不超过360像素。

```
@import url("phone.css") screen and (max-width: 360px);
```

记住，使用CSS中的@import会增加HTTP请求（进而影响加载速度），因此请慎用。

### 在CSS中使用媒体查询

前面我们介绍了在\<head>标签中引入CSS文件，以及通过@import引入CSS文件时使用媒体查询，这两种方式都是链接样式的场景。

但更常见的是在CSS文件内部直接使用媒体查询。比如，如果把以下代码包含进一个样式表，它会在屏幕设备的宽度为400像素及以下时把所有h1元素变成绿色：

```
@media screen and (max-device-width: 400px) {
    h1 {
        color: green;
    }
}
```

首先使用@media规则声明这是一个媒体查询，然后指定匹配的设备类型。
在前面的例子中，我们想把后面的样式应用给屏幕设备（而不是打印设备，即print）。
然后在后面的括号中，进一步指定查询条件。

此时此刻，我得敬告各位：多数情况下，并不需要指定screen。
为什么呢？大家看规范怎么说的：

```
“在针对所有设备的媒体查询中，可以使用简写语法，即胜率关键字all（以及紧随其后的and）。换句话说，如果不指定关键字，则关键字就是all。”
```

因此，除非你真的想针对特定的媒体类型应用样式，否则就不要写screen and了。
后面的例子都会这么做。

### 媒体查询可以测试哪些特性

在响应式设计中，媒体查询中用得最多的特性是视口宽度（width）。
就我个人的经验来看，很少需要到其他设备特性（偶尔会用到分辨率和视口高度）。

不过，为以防万一，这里还是列出了媒体查询3级规定的所有可用特性。
但愿其中有些特性能引起你的兴趣。

- width：视口宽度。
- height：视口高度。
- device-width：渲染表面的宽度（可以认为是设备屏幕的宽度）。
- device-height: 渲染表面的高度（可以认为是设备屏幕的宽度）。
- aspect-ratio: 视口的宽高比。16:9的宽屏显示器可以写成aspect-ratio: 16/9。
- color: 颜色组分的位深。比如min-color:16表示设备至少支持16位深。
- color-index: 设备颜色查找表中的条目数，值必须是数值，且不能为负。
- monochrome: 单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如monochrome: 2，且不能为负。
- resolution: 屏幕或打印分辨率，比如min-resolution: 300dpi。也可以接受美丽多少点，比如min-resolution: 118dpcm。
- scan: 针对电视的逐行扫描（progressive)和隔行扫描（interlace)。例如720p HD TV（720p中的p表示progressive，即逐行）可以使用scan: progressive来判断；而1080i HD TV（1080i中的i表示interlace，即隔行）可以使用scan:interlace来判断。
- grind: 设备基于栅格还是位图。

上面列表中的特性，除scan和grid外，都可以加min或max前缀以指定范围。

```
@import url("tiny.css") screen and (min-width:200px) and (max-width:360px)
```

这里使用最大宽度（max-width）和最小宽度（min-width）设定了范围。

因此，tiny.css只在设备视口介于200像素和360像素之间时才会被应用。

```
CSS媒体查询4级中废弃的特性

CSS媒体查询4级草案中废弃了一些特性，特别是device-height、device-width和device-aspect-ratio。虽然已经支持它们的浏览器还会继续支持，但不建议在新写的样式表中再使用它们了。
```

## 通过媒体查询修改设计

从原理上讲，位于下方的CSS样式覆盖位于上方的目标相同的CSS样式，除非上方的选择符优先级更高或者更具体。因此，可以在一开始设置一套基准样式，将其应用给不同版本的设计方案。这套样式表确保用户的基准体验。然后再通过媒体查询覆盖样式表中相关的部分。

比如，如果是在一个很小的视口中，可以只显示文本导航（或者用较小的字号），然后对于拥有较大空间的较大视口，则通过媒体查询为文本导航加上图标。

现在我们就看一个实际的例子（example_02-02)。

首先是标记：

```
<a href="#" class="Cardlink Carlink_Hearts">Hearts</a>
<a href="#" class="Cardlink Carlink_Clubs">Hearts</a>
<a href="#" class="Cardlink Carlink_Spades">Hearts</a>
<a href="#" class="Cardlink Carlink_Diamonds">Hearts</a>
```

接下来是CSS：

```
.CardLink {
    display: block;
    color: #666;
    text-shadow: 0 2px 0 #efefef;
    text-decoration: none;
    height: 2.75rem;
    line-height: 2.75rem;
    border-bottom: 1px solid #bbb;
    position: relative;
}

@media (min-width: 300px) {
    .CardLink {
        padding-left:  1.8rem;
        font-size: 1.6rem;
    }
}

.CardLink:before {
    display: none;
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    left: 0;
}

.CardLink_Hearts:before {
    content: "❥";
}

.CardLink_Clubs:before {
    content: "♣";
}

.CardLink_Spades:before {
    content: "♥";
}

.CardLink_Diamonds: before {
    content: "方块";
}

@media (min-width: 300px) {
    .CardLink:before {
        display: block;
    }
}

```

### 任何CSS都可以放在媒体查询里

要知道，正常情况下我们编写的任何CSS样式，都可以放在媒体查询里。
因此，使用媒体查询可以从整体上修改一个网站的布局和外观（通常针对不同的视口大小）。

### 针对高分辨率设备的媒体查询

媒体查询的一个常见的使用场景，就是针对高分辨率设备编写特殊样式。
比如：

```
@media (min-resolution: 2dppx) {
    /* 样式 */
}
```

这里的媒体查询只针对每像素单位为2点（2dppx）的屏幕。

类似的设备由iPhone4的视网膜屏，以及其他很多高清屏的安卓机。

减小ddpx值，可以扩大这个媒体查询的适用范围。

为支持更广泛的设备，在使用min-resolution属性时，需要加上适当的浏览器前缀，可以使用工具自动完成。不知道什么是浏览器前缀？


## 组织和编写媒体查询的注意事项

在这里，我们插一部分，谈谈在编写和组织媒体查询的时候都有哪些方式方法。
这些方式方法各有利弊，但至少我们应该知道它们，至于是否采用，那就是另一回事了。

### 使用媒体查询链接不同的CSS文件

从浏览器的角度看，CSS属于“阻塞渲染”的资源。

换句话说，浏览器需要下载并解析链接的CSS文件，然后再渲染页面。

不过，现代浏览器都很聪明，知道哪些样式表（在头部通过媒体查询链接的样式表）必须立即分析，而哪些样式表可以等到页面初始渲染结束后再处理。

在这些浏览器看来，不符合媒体查询指定条件（比如屏幕比媒体查询指定的小）的CSS文件可以延缓执行（deferred)，到页面初始加载后再处理，以便让用户感觉页面加载速度更快。

**“请注意，阻塞渲染仅是指该资源是否会暂停浏览器的首次页面渲染。无论CSS是否阻塞渲染，CSS资源都会被下载，只是说非阻塞性资源的优先级比较低而已。**

再强调一次，所有链接的文件都会被下载下来，只是如果有的文件不必立即应用，那浏览器就不会让它影响页面的渲染。

因此，如果浏览器要加载的响应式页面通过不同的媒体查询链接了4个不同的样式表（分别为不同视口的设备应用样式），那它就会下载4个CSS文件，但在渲染页面之前，它只会解析那个针对当前视口大小的样式表。

###  分隔媒体查询的利弊

编写多个媒体查询分别对应不同的样式表虽然有好处，但有时候也不一定（不算个人喜好或代码分工的需要）。

多一个文件就要多一次HTTP请求，在某些条件下，HTTP请求多了会明显影响页面加载速度。
Web开发可不是件容易的事儿！此时应该关注的是网站的整体性能，最好在不同设备上对不同的情形都做相应的测试，比较之后再决定。

我对这件事的看法是，除非有充裕的时间让你去做性能优化，否则我一般都不后悔指望在这方面获取性能提升。我会首先确认：

- 所有图片都压缩过了；

- 所有脚本都拼接和缩短了；

- 所有资源都采用了gzip压缩；

- 所有静态内容都缓存到了CDN；

- 所有多余的CSS规则都被清除了。

之后，我才可能会考虑，为了再提升一些性能，是否需要把媒体查询分隔开，让它们分别引用不同的CSS文件。

```
gzip是一种压缩和解压缩的文件格式。主流一点的服务器都支持gzip压缩CSS，从而让服务器发送给设备的文件明显“瘦身”（到了设备之后，再解压成原来的格式）。
```

### 把媒体查询写在常规样式表中

除非在极端情况下，否则我都建议在既有的样式表中写媒体查询，跟常规的规则写在一起。

如果你也是这样想的，那么还有一个问题需要考虑：是该把媒体查询声明在相关的选择符下面，还是该把相同的媒体查询并列起来，每个媒体查询单独一块？这个问题问得好啊。

## 组合媒体查询还是把它们写在需要的地方

我个人喜欢把媒体查询写在需要它的地方。比如，我想根据视口大小在样式表中的几个地方改变几个元素的宽度，我会这样做：

```
.thing {
    width: 50%;
}

@media screen and (min-width: 30rem) {
    .thing {
        width: 75%;
    }
}

/*这里是另外一些样式规则*/

.thing2 {
    width: 65%;
}

@media screen and (min-width： 30rem) {
    .thing2 {
        width: 75%;
    }
}
```

这样写看起来有点蠢，两个媒体查询的条件相同，都针对屏幕最小宽度为30rem的情况。
像这样重复写两遍@media真的是冗余和浪费吗？难道不该把针对相同条件的CSS规则则都组织到一个媒体查询块里吗？像这样：

```
.thing {
    width: 50%;
}

.thing2 {
    width: 65%;
}

@media screen and (min-width: 30rem) {
    .thing {
        width: 75%;
    }
    .thing2 {
        width: 75%;
    }
}
```

当然这也是一种方式。不过，从维护代码的角度来看，这种写法不利于维护。
当然两种写法都对，只是我比较倾向于针对某个选择符写一些规则，然后如果该规则需要视条件而变，那我就把相应的媒体查询紧接着写在它的下面。这样在需要查找与某个选择符相关的规则时，就不用再从一个一个的代理块里找了。

对于这种写媒体查询的方式，你说它会造成冗余是绝对没错的。但从控制文件大小的角度说，难道这样写媒体查询的做法真的不可取吗？没错，谁也不希望CSS文件过度膨胀。但事实上gzip压缩（应该用它来压缩服务器上的所有可以压缩的资源）完全可以把差别降到可以忽略不计的程度。

总之，在标准样式之后，紧接着谢谢媒体查询，根本用不着担心文件大小。

## 关于视口的meta标签

为了利用媒体查询，应该让小屏幕以其原生大小来显示网页，而不是现在980像素宽度窗口中渲染好，让用户去放大或缩小。

2007年苹果在发布iPhone的时候，就引入了一个针对视口的meta标签。
目前安卓机和其他手机基本都支持这个标签了。
这个用于视口的meta标签，是网页与移动浏览器的接口。
网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。

在可以预见的未来，任何响应式如果希望在小屏幕设备上好好显示网页，都必须添加这个meta标签。

这个视口\<meta>标签应该放在HTML的\<head>标签中。
可以在其中设置具体的宽度（比如使用像素单位），或者设置一个比例（比如2.0，即实际大小的两倍）。

下面这行代码设置以内容实际大小的两倍（百分之两百）显示：

```
<meta name="viewport" content="initial-scale=2.0, width=device-width"/>
```

好，现在分析一下前面的\<meta>标签。

首先，name="viewport"表示针对视口，这不用说了。
接着content="initial-scale=2.0"的意思是“把内容放大为实际大小的两倍”。
最后，width=device-width告诉浏览器页面的宽短等于设备的宽度。

通过这个\<meta>标签还可以控制用户可以缩放页面的程度。
下面的例子允许用户最大将页面放大到设备宽度的三倍，最小可以将页面缩小至设备宽度的一半。

```
<meta name="viewport" content="width=device-width, maximum-scale=3, minimum-scale=0.5"/>
```

设置可以完全禁止用户缩放。
虽然允许缩放是一个重要的无障碍特性，但现实当中很有有必要这么做：

```
<meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
```

其中user-scalable=no是禁止用户缩放的。

没错，我们又把initial-scale又改回了1.0，意思是让移动浏览器在其视口的宽度中渲染网页。将width设置为device-width就是要在所有支持的移动浏览器中，以百分之百的视口宽度来渲染页面。

大多数情况下，都可以使用这个meta标签：

```
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
```

## 媒体查询4级

CSS媒体查询4级（CSS Media Queries Level 4)还是草案(http://dev.w3.org/csswg/mediaqueries-4/)，其中的新特性还没有多少浏览器支持。换句话说，虽然我们会在这里介绍它们，但将来它们很可能还会改变。请大家在真正使用这些新特性时，仔细研究一下浏览器支持情况以及语法是否正确。

### 可编程的媒体特性

通常，如果浏览器里没有JavaScript，我们会给某个HTML标签添加一个类，而在JavaScript出现时再替换该类。这样就可以根据这个HTML类来决定要加载什么代码（及CSS）。最常见的场景是通过这种方式为启用JavaScript的用户编写特有的CSS规则。

这个做法有时候会误导人。比如，默认情况下的HTML标签是这样的：

```
<html class="no-js">
```

如果JavaScript在这个页面中运行了，则它要做的第一件事就是替换这个类:

```
<html class="js">
```

然后，我们就可以只针对支持JavaScript的浏览器编写相应的样式了。比如：.js .header { display: block; }。

CSS媒体查询4级致力于为这个做法在CSS中提供更标准的实现方式：

```
@media (scripting: none) {
    /* 没有JavaScript时的样式 */
}

可以使用JavaScript时：

@media (scripting: enabled) {
    /* 有JavaScript时的样式 */
}
```

最后，这个新规范还为仅开始时可以使用JavaScript提供了一个值。规范中针对这个值给出的例子，就是打印页面时，一开始可以使用JavaScript来排版，然后就没有JavaScript可用了。此时，可以这样写CSS：

```
@media (scripting: initial-only) {
    /* JavaScript只在一开始有效的样式 */
}
```

### 交互媒体特性

以下是W3C对指针媒体特性的描述：

“指针媒体特性用于查询鼠标之类的指针设备是否存在，以及存在时其精确的位置。如果设备由多种输入机制，指针媒体特性必须反映由用户代理决定的"主"输入机制的特征。”

指针特性有三个值：none、coarse和fine。

coarse指针设备代表触摸设备中的手指。不过，这个值也可以是游戏机中的指针等不像鼠标那样能够提供精确控制的机制。

```
@media (pointer: coarse) {
    /*针对coarse指针的样式 */
}
```

fine指针设备可能是鼠标，也可能是手写笔或其他未来可能出现的精确指针设备。

```
@media (pointer: fine) {
    /*针对精确指针的样式 */
}
```

个人觉得，浏览器应该尽快实现这几个特性。这是因为目前还很难确切地知道用户是在使用鼠标，还是触摸，亦或两者都有，以及某一时刻他们在使用哪一种。

### 悬停媒体特性

顾名思义，悬停媒体特性就是用来测试用户是否可以通过某种机制实现在屏幕元素上悬停的 。如果用户有多种输入机制（触摸或鼠标），则检测主输入机制。以下是这个特性的可能值和代码示例。

对于没有悬停能力的情况，可以通过none值检测：

```
@media (hover: none) {
    /* 针对不可悬停用户的样式 */
}
```

对于可以悬停但必须经过一定启动步骤的用户，可以使用on-demand:

```
@media (hover: on-demand) {
    /* 针对可通过启动程序实现悬停用户的样式 */
}
```

对于可以悬停的用户，可以使用hover：

```
@media (hover) {
    /* 针对可悬停用户的样式 */
}
```

另外，还有any-pointer和any-hover媒体特性。
这两个特性与前面的pointer和hover类似，只不过测试的不光是主输入机制，而是任意可能的输入设备。

### 环境媒体特性

要是能根据用户的环境来改变设计多好啊！
比如，根据环境光线的亮度。
这样，如果用户身处光线很暗的房间，我们可以相应减少所用颜色的亮度值。
或者相反，在光线充足的环境里，提高亮度。

环境媒体属性就是为解决这个问题而生的。

```
@media (light-level: normal) {
    /*针对标准亮度的样式 */
}

@media (light-level: dim) {
    /*针对暗光线条件下的样式 */
}

@media (light-level: washed) {
    /* 针对强光线条件的样式 */
}
```

4级媒体查询尚未得到广泛支持，而且规范本身还有可能变动。
不过，了解未来几年可能有什么新特性可以使用还是有必要的。
