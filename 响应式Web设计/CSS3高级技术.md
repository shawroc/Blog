# CSS3 高级技术

---
绝大部分引用自《响应式Web设计 HTML5和CSS3实战（第2版）
---

CSS3 的高级属性十分适合响应式设计，很多情况下，我们可以用它来代替图片。
这样既省时，又能增加代码的可维护性和灵活度，还能让页面更“轻”。

这些优势即便是在固定宽度的桌面设计中也很有用，在响应式设计中则更加重要，使用CSS可以在不同视口中轻松创造出不同的酷炫效果。

## CSS3 的文字阴影特效

text-shadow 是最被广泛支持的CSS3特性之一。
和@font-face 一样，它有过一段短暂的前生，但是在CSS2.1中被废弃了。

万幸，它再次转世投胎，并被广泛支持（所有的现代浏览器和IE9以上的浏览器都支持）。

我们来看一下基本语法：

```
.element {
    text-shadow: 1px 1px 1px #ccc;
}
```

记住，缩写值的规则是先右后下（当然，你可以将其视为顺时针顺序）。
因此，第一个值是阴影的右侧偏移量，第二个值是阴影的下方偏移量，第三个值是模糊距离（阴影从有到无的渐变距离），最后一个则是色值。

要想让阴影往左上方偏移，可以使用负值。如下：

```
.text {
    text-shadow: -4px -4px 0px #dad7d7;
}
```

色值并不一定需要用十六进制表示。也可以使用HSL(A)或者RGB(A):

```
text-shadow: 4px 4px 0 hsla(140, 3%, 26%, -.5);
```

需要谨记的是，只有同时支持HSL/RBG色值模式和text-shadow的浏览器才可以渲染出这种效果。

你可以把阴影值设为任何合法的CSS长度单位，如em、rem、ch等。当我个人较小使用em和rem单位。诸如 1px 和 2px 这样的值在所有视口都看起来比较好。

当然，我们也可以通过媒体查询在特定的视口下去除文字阴影效果。
使用none值即可。

```
.text {
    text-shadow: 0.0625rem 0.0625rem 0 #bfbfbf;
}

@media (min-width: 30rem){
    .text {
        text-shadow: none;
    }
}
```

### 省略 blur 值

如果你不需要给文字阴影添加模糊效果，那么可以在声明中把 blur 值省略。

```
.text {
    text-shadow: -4px -4px #dad7d7;
}
```

这种种写法是完全合法的。浏览器会在没有第三个长度值的情况下把前两个值作为偏移量。

### 多文字阴影

我们可以添加多个阴影效果，通过逗号分隔即可，比如：

```
.multiple {
    text-shadow: 0px 1px #fff, 4px 4px 0px #dad7d7;
}
```

由于CSS会忽略空白，你可以这样排版以增加可读性。

```
.text {
    /* 100 of vh or vw, whichever is larger divided by 40 */
    font-size: calc(100vmax / 40);
    /* right and down */
    text-shadow: 3px 3px #bbb,
    /* left and up */
    text-shadow: -3px -3px #999;
}
```

## 盒阴影

盒阴影容许你在元素的内部或者外部创建盒状的阴影效果。
掌握了文字阴影，盒阴影就是小菜一碟了。

它们遵循相同的语法： 水平偏移值、垂直偏移值、模糊距离、阴影尺寸，以及阴影颜色。

四个长度值中只有两个是必需的，当最后两个长度值不存在的时候，颜色值会被当做阴影颜色，而0值会被添加到模糊半径上。

让我们来看一个简单的例子：

```
.shadow {
    box-shadow: 0px 3px 5px #444;
}
```

默认的box-shadow是设置在元素外部的。
另外一个可选关键词inset容许在元素内部使用box-shadow。

### 内阴影

box-shadow 属性可以用于建立一个inset阴影。
使用的语法和普通盒阴影效果唯一的区别是，在前头添加了inset关键字：

```
.inset {
    box-shadow: inset 0 0 40px #000;
}
```

所有的功能和之前是一致的，但是inset声明让浏览器把阴影设在了元素的内部。

### 多重阴影

和text-shadow一样，你也可以添加多个 box-shadow。
使用逗号分隔 box-shadow，它们会按照从底部到顶部（从最后一个到第一个）的顺序被添加。

所以切记，在代码里越接近顶层的效果在浏览器展示的时候也月接近“顶层”。
和text-shadow一样，你可以用空白来叠加不同的box-shadow。

```
/*按顺序添加*/
box-shadow: inset 0 0 30px hsl(0, 0%, 0%),
            inset 0 0 70px hsla(0, 97%, 53%, 1);

```

把多个值在代码中堆起来会在使用版本控制系统时带来极大的便利。
这会让你轻易地看出两个文件版本的区别。
这就是我为什么习惯把选择器一个接一个堆起来。

### 阴影尺寸

老实说，多年来我都不太理解“阴影尺寸”这一词的意思。
我并不觉得“尺寸”（spread）这个名字比较贴切。
我更偏向于使用偏移。
让我解释一下。

这里使用的是标准的box-shadow。
右侧的盒子使用了一个负的阴影尺寸值。
它是用第四个值设置的。
下面是相关代码：

```
.no-speed {
    box-shadow: 0 10px 10px;
}

.spread {
    box-shadow: 0 10px 10px -10px;
}
```

阴影尺寸让你可以按照你的设置在所有方向上缩放阴影效果。
在这个例子中，一个负值可以在各个方向上缩小阴影的效果。
最终效果就是我们只看到底部有阴影，而不是看到阴影全方位地“泄漏”出来。
因为模糊距离被负的阴影尺寸所抵消了。

## 背景渐变

在没有CSS3的日子里，如果想做一个背景渐变效果，就要用一个很细的渐变切片进行水平/垂直平铺。
对于使用图片而言，这确实是一个经济实用的好方案。
一张仅有一两像素宽的图片，不会给宽带造成太大负担，而且它可以用在网站的多个元素上。

然而，如果我们想调整渐变效果，仍然需要返回到图片编辑器里。
另外，内容可能偶尔会大大而超过渐变背景。
这个问题增加了响应式设计的复杂性，因为在不同视口下，页面的任意一部分都会增大。

自从CSS的background-image 横空出世后，事情变得容易多了。
作为CSS Image Values and Replaced Content Module Level 3文档中的一部分，CSS的这个属性容许我们创造线性或者径向渐变背景。

让我们看看如何使用它们。

想要了解 CSS Image Values and Replaced Content Module Level 3，[请参阅](https://www.w3.org/TR/css3-images/)。

### 线性渐变语法

linear-gradient的最简表达方式看上去像这样：

```
.linear-gradient {
    background: linear-gradient(red, blue);
}
```

这会创建一个从红色渐变为蓝色的（默认从顶部开始）的渐变背景。

#### 确定渐变方向

有几种方式可以确定渐变的方向。一般而言，渐变将从你设定的方向的反方向开始。当没有设置方向的时候，渐变会默认从顶部从底部。

例如：

```
.linear-gradient {
    background: linear-gradient(to top right, red, blue);
}
```

在这段代码中，渐变的方向设定为顶部右侧。
那么它会从底部左侧开始从红色渐变为蓝色。

如果你数学思维比较好，可能倾向于这么使用：

```
.linear-gradient {
    background: linear-gradient(45deg, red, blue);
}
```

不过需要主要的是，在一个矩形里，一个指向顶部右侧的渐变（总是指向元素右上角）和指向45度的渐变（总是指向45度）还是有差异的。

另外，你也可以让渐变效果从不可见的区域中开始。
如下列：

```
.linear-gradient {
    background: linear-gradient(red -50%, blue);
}
```

这样渐变会在容器内部不可见的地方就开始渲染。

事实上，在上面这个例子中我们使用了色标来定义颜色什么时候开始与结束。
我们来仔细看看。

#### 色标

在背景渐变中最难理解的大概就是色标了。
它们用于把渐变中的某个点设定为特定颜色。
你可以使用色标定义复杂的渐变效果。
看以下例子：

```
.linear-gradient {
    margin: 1rem;
    width: 400px;
    height: 200px;
    background: linear-gradient(#f90 0, #f90 2%, #555 2%, #eee 50%, #555 98%, #f98 98%, #f90 100%);
}
```

这就是linear-gradient 渲染的效果。

因为方向未被定义，所以默认从顶部到底部进行渐变。

渐变效果中的色标是用逗号分隔的。
第一部分是颜色，第二部分是颜色的位置。
一般建议不要混用单位。
你可以在一个渐变效果中添加多个色标，而且可以使用关键词、十六进制、RGBA或者HSLA 等色值写法。

要注意的是，多年依赖已经产生了多种不同的背景渐变语法。
所以兼容以往的写法是个比较困难的事情。尽管这样我可能会显得十分唠叨，但我还是要叮嘱一下，你可以使用Autoprefixer来解决这些问题。这允许你使用现代的W3C标准语法，而且它会自动兼容先前的写法。

想要了解W3C对线性渐变背景的标准定义，请[参阅](https://www.w3.org/TR/css3-images/)

#### 兼容旧式浏览器

要兼容不支持背景渐变效果的浏览器，只需要在之前定义个背景颜色就可以了。
这样，老旧浏览器至少会渲染一个背景。

如下例：

```
.thing {
    background: red;
    background: linear-gradient(45deg, red, blue);
}
```

### 径向渐变背景

在CSS里建立一个径向渐变也是十分简单的。效果一般是从一个中心发散成为圆形或椭圆形的渐变效果。


下面是径向渐变背景的语法：

```
.radial-gradient {
    margin: 1rem;
    width: 400px;
    height: 200px;
    background: radial-gradient(12rem circle at bottom,yellow, orange, red);
}
```

理解径向渐变语法

在background属性后，我们设定radial-gradient。在第一个逗号前，我们定义渐变大小、形状和所在位置。上例中我们使用了直径为12rem的圆形渐变效果，下面我们看看其他例子。

- 设置为5em会生成一个直径大小为5em的圆形渐变效果。如果只提供大小的话，会默认使用圆形。

- 设置为circle会生成一个占满整个容器的圆形渐变效果(径向渐变的直径默认为容器最长边)。

- 设置为40px 30px会生成一个X方向宽为40像素、Y方向高为30像素的椭圆形。

- 设置为ellipse会生成和容器大小一致的椭圆形。

在定义了大小和形状后，我们定义渐变的位置。默认的位置是容器的中心。但是我们可以尝试一下其他做法。

- at top right 表示径向渐变的中心在右上方。

- at right 100px top 20px表示径向渐变的中心在距右边框100像素、上边框20像素处。

- at center left 表示径向渐变的中心在左边框中间处。

我们暂停对径向渐变大小、形状和位置的定义。接下来定义色标，其使用方法有linear-gradient 一致。

**总结一下，在第一个逗号前设置大小、形状和位置，然后设置需要的色标（每个色标之间用逗号分隔）。

### 为响应式而生的关键字

在响应式设计中，你会发现按照比例设置渐变效果大小比按照规定像素设置更为有用。
你会发现无论元素的大小如何改变，都能顾被你的渐变效果覆盖住。

另外，你还可以使用一些方便的大小关键词。

```
background: radial-gradient(closest-side circle at center, #333, blue);
```

下面了解一下这些关键词。

- closest-side：在渐变形状为圆形的情况下，渐变形状会与距离中心最近的边框相切；在椭圆形的情况下，则会与距离中心最近的两个边框相切。

- closest-corner: 渐变形状会与距离中心最近的角相切。

- farthest-side: 和closest-side相反。在圆形的情况下，与距离中心最远的边相切。在椭圆的情况下，与距离中心最远的两边相切。

- farthest-corner: 渐变形状会与距离中心最远的角相切。

- contain: 等价于closest-side

想要了解W3C对径向渐变背景的标准定义，请[参阅](https://www.w3.org/TR/css3-images/)。

制作完美渐变效果的简便方法

手工制作渐变效果是比较困难的。你可以使用线上的渐变效果生成器。我最喜欢用的是[colorzilla](http://www.colorzilla.com/gradient-editor/)。它使用一个图形化界面编辑器来方便用户选择颜色、色标位置、渐变形式（线性或者径向渐变），甚至包括最后生成的色值的表示方法（HEX、RGB(A)、HSL(A)）。它也预置了一些渐变效果让你进一步调步。它还提供可以兼容老式浏览器的代码。仍然不够方便吗？那么尝试下基于图片生成CSS渐变效果功能？ 我觉得它能满足你的需求。

## 重复渐变

CSS3 也可以让我们创建重复渐变背景效果。让我们看一下如何实现：

```
.repeating-radial-gradient {
    background: repeating-radial-gradient (black 0px, orange 5px, red 10px);
}
```

首先，在linear-gradient 或者 radial-gradient 前添加 repeating 前缀，接下来的语法和普通的渐变效果是一致的。在本例中，我使用了像素值来标记色标之间的距离（分别是0px、5px和10px）。

你也可以使用百分值进行标记。
为了展示最佳效果，建议使用同一种计量单位。

想要了解W3C对重复渐变的标准定义，请[参阅](https://www.w3.org/TR/css3-images)。

另外，我还有一种使用渐变背景效果的方法要分享给你。

## 使用渐变背景创造图案

在设计中，我经常使用线性渐变，很少使用径向渐变和重复渐变。然而，有些聪明的人已经学会使用渐变来创造背景渐变图案了。

让我们欣赏一下来自CSS高手 Lea Verou 的 CSS3背景图案集合，你可以通过 [Lea Verou](http://lea.verou.me/css3patterns)观看：

```
.carbon-fibre {
    margin: 1rem;
    width: 400px;
    height: 200px;
    background:
        radial-gradient(black 15%, transparent 16%) 0 0,
        radial-gradient(black 15%, transparent 16%) 8px 8px,
        radial-gradient(rgba(255, 255, 255, 0.1) 15%, transparet 20%) 0 1px,
        radial-gradient(rgba(255, 255, 255, 0.1) 15%, transparent 20%) 8px;
        background-color: #282828;
        background-size: 16px 16px;
}
```

只需要几行CSS代码，我们就拥有了易于修改的、响应式的、可扩展的背景图案。

你可能会发现，添加backgroud-repeat: no-repeat 可便于了解它的工作原理。

与以往一样，我们可以依靠媒体查询来在不同的响应式场景中使用不同的效果。例如，一个渐变图案可能在小视口中比较好看，但是在视口较大的情况下，使用一个纯色的背景会比较好：

```
@media (min-width: 45rem) {
    .carbon-fibre {
        background: #333;
    }
}
```

## 多张背景图片

虽然现在可能有点过时了，但是过去曾十分流行在页面顶部和底部使用不同的背景图片，或者在页面某个内容区的顶部和底部使用不同的背景图片。

在使用CSS2.1的年代，要实现这种效果通常需要使用额外的标记（为页头背景和页脚背景各设置一个元素）。

在CSS3中，你可以在一个元素上堆叠多个背景图片。

下面是语法：

```
.bg {
    background:
        url('../img/1.png'),
        url('../img/2.png'),
        url('../img/3.png');
}
```

和多重阴影的堆叠顺序一样，图片列表中先出现的图片会被安置在越靠近用户的位置。
你甚至可以在同一个声明中添加背景色：

```
.bg {
    background: 
        url('../img/1.png'),
        url('../img/2.png'),
        url('../img/3.png') left bottom,
        black;
}
```

在最后才设定背景颜色，这样颜色就会在所有图像的下方。

当声明多个背景元素的时候，你不需要每行只写一个图片。
我只是觉得这样的代码便于阅读而已。

不支持多重背景的浏览器（如IE8及之前的版本）会忽略这条声明，所以你最好在使用多重声明前声明一个“正常”的背景属性来兼容老旧浏览器。

使用多重背景的时候，如果你使用透明背景的PNG图片，下层图片将会透过上层图片的透明背景显示出来。但是背景图片并不总是要一个接一个堆叠在一起，也并不总是要大小相同。

### 背景大小

可以使用背景大小(background-sieze)属性为每个图片设置大小。语法如下：

```
.bg {
    background-size: 100% 50%, 300px 400px, auto;
}
```

每张图片的大小（第一个是宽度，第二个是高度）按照它们在背景属性中的顺序声明，用逗号分隔。

在上例中，你可以使用百分比、像素或者以下关键词。

- auto: 让图片保持其原生大小。

- cover:  保持图片比例，拓展至覆盖整个元素。

- contain: 保持图片比例，拓展图片让其最长边保持在元素内部。

### 背景位置

如果你有不同的背景图片、不同的大小，接下来要做的就是放置在不同的位置上了。那么background-position就可以满足你的需求了。

让我们把所有的图片功能以及前几章介绍的几个响应式单位结合起来。

让我们用一个简单的元素和三张背景图片创建一个简单的太空场景。
图片设置为不同的大小，并使用三种不同的方式来放置。

```
.bg-multi {
    height: 100vh;
    width: 100vw;
    background: 
        url('rosetta.png'),
        url('moon.png'),
        url('starts.jpg');
    background-size: 75vmax, 50vw, cover;
    background-position: top 50px right 80px, 40px 40px, top center;
    background-repeat: no-repeat;
}
```

我们把星空图放在底层，然后放置月亮图，最后放入一张罗塞塔空间探测器图片。
要注意的是，如果你调整浏览器窗口大小，会发现响应式长度单位工作得很好（vmax、vh和vw）并且能保持比例，而基于像素的单位却不一样。

**背景位置默认为左上角**

### 背景属性的缩写

可以把所有不同的背景属性都组合在一起，写在一个属性里。
你可以阅读[规范](https://www.w3.org/TR/css3-background/)。

不过到目前为止，我的经验告诉我，缩写经常会导致很多奇奇怪怪的问题。

因此，我建议不要使用缩写，并且先声明多重背景图片，然后声明背景大小，最后声明背景位置。

想要了解W3C对多重背景的标准定义，请参阅 https://www.w3.org/TR/css3-background/。

## 高分辨率背景图像

媒体查询让我们可以在不同的视口大小下加载不同分辨率的图像。

下例是一段为“正常”和高清屏幕选择不同分辨率图片的代码。

```
.bg {
    background-image: url('bg.jpg');
}

@media (min-resolution: 1.5dppx) {
    .bg {
        background-image: url('bg@1_5x.jpg');
    }
}
```

媒体查询包括长度、高度或者其他支持的弧形。

在本例中，我们定义图片bg@1_5x.jpg应该使用的最小分辨率为 1.5dppx（设备像素与CSS像素比）。

我们也可以使用dpi（每英寸点数）或者 dpcm（每厘米点数）。

然而，即使不考虑它们的支持度，我认为dppx仍然是最易于理解的单位。

2dppx意味着两倍的分辨率，3dppx则意味着三倍分辨率。

想象一下，如果你使用的是dpi会是多麻烦的一件事。

“标准”的分辨率应该是96dpi，那么两倍的分辨率就应该是192dpi。

dppx单位的支持度并不算特别好。
所以，你还是需要编写其他版本的媒体查询方法来解决分辨率的问题，或者依靠工具来解决。

```
关于性能

要谨记过大的图片会拖慢网站的速度，影响用户的体验。尽管背景图片并不会阻止网页的正常阅读（你在背景图片正常加载的时候仍然可以阅读网页的其他部分），但是它会使你的页面变重，这对于那些要为流量付费的用户十分不友好。
```

## CSS滤镜

box-shadow有一个显而易见的问题。顾名思义，元素的阴影只能是矩形。
下面是使用box-shadow创建的三角形阴影：

然而这并不是我想要的结果。

好在，我们可以用CSS滤镜来解决这个问题。CSS滤镜是Filter Effects Module Level 1文档中的一部分（https://www.w3.org/TR/filter-effects/）。

它的支持度并没有box-shadow那么高，但是在渐进增强的方式中表现依然十分不错。
如果浏览器不支持滤镜，那么它会将其忽略。
而在支持滤镜的浏览器上，绚丽的效果就会被渲染出来。

以下是CSS滤镜的格式：

```
.filter-drop-shadow {
    filter: drop-shadow(8px 8px 6px #333);   
}
```

在filter属性后我们首先要声明使用哪种滤镜。

drop-shadow 和 box-shadow 拥有相似的语法： X方向偏移量、Y方向偏移量、模糊大小、阴影尺寸和颜色。

CSS滤镜是基于被广泛支持的SVG滤镜。

## 可用的CSS滤镜

可供我们选择的CSS滤镜并不多，下面我们将逐个介绍。

- filter: url('./img/filters.svg#filterRed')：首先顶一个SVG滤镜来使用。

- filter: blur(3px)：使用一个简单的长度值（不是百分比）。

- filter: brightness(2): 使用从0到1的值或者从0%到100%的值。0/0%意味着全黑，1/100% 意味着正常没有变化，而任何更高的值意味着更高的亮度。

- filter: contrast(2): 使用从0到1的值或者从 0%到 100%的值。0/0%意味着全黑，1/100%意味着正常没有变化，而更高的值意味着更高的对比度。

- filter: drop-shadow(4px 4px 6px #333): 阴影

- filter: grayscale(0.8): 使用从0到1或者从0%到100%的值表示元素灰度化的程度。0表示没有灰度化，而1表示完全灰度化。

- filter: hue-rotate(25deg):  使用从0度到360度表示颜色在色轮上的变化角度。

- filter: invert(75%): 使用从0到1的值或者从0%到100%表示元素中反色的程度。

- filter: opacity(50%): 使用从0到1的值或者从0%到100%的值来改变元素的透明度。这和你熟悉的opacity属性是相似的。然而滤镜是可以多个同时使用的，这让透明效果可以和其他滤镜效果结合在一起。

- filter: saturate(15%): 使用从0 到 1 的值或者从0% 到 100% 来表示图像的饱和度。高于 1/100%的值会增加额外的饱和度。

- filter: sepia(0.74): 使用从0 到 1的值或者从 0% 到 100%来为元素添加褐色滤镜。 0/0% 表示元素没有变化，而更高的值则表示褐色化程度的提升， 1/100%表示最高的效果。

## 使用多个CSS滤镜

你可以轻松地使用多个滤镜：用空格分隔它们即可。
如下例，你就可以同时使用opacity、blur和sepia滤镜：

```
.MultipleFilters {
    filter: opacity(10%) blur(2px) sepia(35%);
}
```

**注意：除了hue-rotate滤镜外，都不能使用负值。**

CSS滤镜在给我们带来绚丽强力效果的同时，也可以让我们可以切换各种效果。

然而，在你为这些新功能痴迷的时候，我希望你可以先考虑一下性能问题。

## CSS 性能的警告

当提到CSS性能的时候，我希望你记住这么一句话：

“括号外的决定了页面的架构，括号内的决定了页面的性能。” ——Ben Frain

让我拓展一下我这句小小的格言。

就我目前所能证明的，担心CSS选择器（大括号外面的部分）的性能表现使无意义的。
你可以在这个网址查看我的[证明](http://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles)。

然而，CSS中某个部分真的会让页面慢下来，就是那些聪明的、“昂贵的” CSS属性（大括号内的部分）。当我们使用“昂贵的”这一形容词，也就意味着它给浏览器带来了极高的复合。这是浏览器讨厌做的繁重活儿。

我们很容易猜到是什么给浏览器带来了额外的工作量，就是那些在渲染前必须进行的计算工作。举个例子，一个是只有单一背景颜色的标准div容器，另外一个则是在多种渐变背景上叠加的一幅半透明的图像，并且该容器是圆角的，而且添加了drop-shadow滤镜。后者必然更加昂贵。它会给浏览器带来更多计算性的工作，因此会导致更多的开销。

因此，慎重地使用滤镜效果。如果可以，在你需要支持的最低级设备上测试一下页面速度是否受到了影响。至少要在开发者工具上进行测试，去掉连续的页面重绘等你认为可能引起问题的现象。

你也可以从数据中（如需要花费多少毫秒才能渲染当前的页面）判断出哪种效果才是最有效的。这个数字越低，页面的效率越高（不过要注意浏览器/平台间的差异性，因此，最好在真实设备上进行测试）。

要了解更多，我推荐以下资源：https://developers.google.com/web/fundamentals/performance/rendering/。

**CSS 遮罩和剪裁的注意事项**

随着CSS Masking Module Level 1的到来，在不久的将来，CSS就可以提供遮罩和剪裁功能了。

这些功能让我们可以把图片剪成任意形状（通过SVG或者一系列多边形的点来指定）。

尽管该规范正出于CR阶段，但在我编写本书的时候，浏览器的实现实现太笨重，所以我不作推荐。

不过在你阅读此书的时候，浏览器的实现很有可能已经十分可靠了。

为了方便查阅，我推荐你在 https://www.w3.org/TR/css-masking-1/ 阅读相关规范。

同时我认为 Chris Coyier 在他的文章里很好地解释了有哪些属性已经被很好地实现了。

大家可以到 https://css-tricks.com/clipping-masking-css 上进行阅读。

最后，可以在 https://alistapart.com/article/css-shapes-101 阅读 Sara Souedan的文章，来了解将来我们可以使用什么！！

## 小结

在本章中，我们了解了一系列用于设计轻巧美观的响应式页面的CSS功能。
CSS3 的背景渐变功能使我们减少了对背景图片的依赖。

我们甚至可以用它来创建无限重复的背景图案。

我们还学会了如何用text-shadow 来创建简单的文本增强效果，以及如何使用 box-shadow 来为元素加上内阴影和外阴影。

我们也了解了CSS滤镜。

它们使我们只依靠CSS就能实现令人惊讶的视觉效果，并且可以结合起来同时使用。

在下一章，我们将注意力转向SVG。

尽管它已经是一项十分成熟的技术，但是只有在今天的高性能和响应式网站里，才能大展拳脚。

