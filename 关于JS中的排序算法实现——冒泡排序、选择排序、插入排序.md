这是JavaScript排序算法的开篇介绍。你可能会有疑问？既然已经有一些内置的方法来对列表进行排序，为什么还要学习这些排序算法呢？

## 为什么要学习排序算法？

- 简短的答案： 

    因为Google和一些大型的互联网科技公司需要你了解他们，为了你自己的前途，你必须掌握他们。

- 专业的回答： 

    根据数据大小的不同，你所构建的算法的时间和空间复杂度是非常重要的，不同的排序算法会有不同的效率，这会对应用程序产生重大影响。所以我们必须去掌握他们。
    
    学习排序算法是提高软件工程师技能和分析需求能力的最佳途径之一，是练习分析时间和空间复杂度的好方法，并且可以为问题提供聪明的解决方案。

    当你开始面试下一份工作时，现在就开始学习这些技能将会极大地帮助你。

    你申请的任何一家大型科技公司都要求你对算法和数据结构有很强的理解能力，这一点是尤其确定的。


正如你所猜测的，排序算法就是获取一组数据并对他们进行排序——通常按字母或数字顺序进行排序。

## 算法的特征

一个算法应该具有以下五个重要的特征：

- 有穷性（Finiteness），算法的有穷性是指算法必须能在执行有限个步骤之后终止。

- 确切性（Definiteness），算法的每一步骤必须有确切的含义。

- 输入项（Input）, 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。

- 输出项（Output），一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的。

- 可行性（Effectiveness），算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤可以在有限时间内完成（有时也称之为有效性）。


## 冒泡排序（Bubble Sort）

强烈建议从冒泡排序(Bubble Sort)开始来学习排序算法。

冒泡排序（Bubble Sort），是计算机领域的一种比较简单的排序算法。

它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序错误就把它们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换。

这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸硬料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

### 冒泡排序算法原理

冒泡排序算法的原理如下：

1. 循环遍历，比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。
3. 每一轮循环结束，会有一个最大的元素“浮出”。
4. 持续对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### JavaScript实现冒泡排序

```

function BubbleSort(arr) {
    for(var i = 0; i < arr.length; i++) {
        for(var j = 0; j < arr.length -1 -i; j++) {
            if(arr[j] > arr[j+1]) {
                var temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    return arr;
}

var arr = [5,1,2,4,0];

BubbleSort(arr); //[0,1,2,4,5];

```

## 选择排序（Selection Sort）

选择排序（Selection Sort）是一种简单直观的排序算法。

它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

实现思想：

对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小，则用一个变量来记住它的位置。

依次比较，一轮循环借宿，就找到了最小的那个数的下标了。

然后，让第一个元素和数组中最小的那个数交换位置和值。

后续循环，依次类推。


### JavaScript实现选择排序

```

function SelectionSort(arr) {
    for(var i = 0; i < arr.length; i++) {
        var minValueIndex = i;
        for(var j = i + 1; j < arr.length; j++) {
            if(arr[minValueIndex] > arr[j]) {
                minValueIndex = j;
            }
        }
        var temp = arr[i];
        arr[i] = arr[minValueIndex];
        arr[minValueIndex] = temp;
    }
    return arr;
}

var arr = [5,4,3,2,1];

SelectionSort(arr); //  [1, 2, 3, 4, 5]

```


## 插入排序（Insertion Sort）

插入排序的基本思想：

每步将一个待排序的数据，按其大小插入已经排序的数据中的适当位置，直到全部插入完毕。

有点抽象~

具象化一下，想象一下你在玩扑克牌。你一张一张的抽牌，每一次抽到手的牌，你都根据手中已有的牌来进行一次插入，每一次根据牌面大小，把这一张牌放在适当的位置。

1. 如果第一张牌你得到的是5。 你就握着这张牌，不需要干任何事情。
2. 如果第二张牌是2，你会把它放在5前面，这样两张牌就按大小排好了序。当你把2放在5的左边，实际上你是把5原本的位置移动到第二个位置。第一个位置，就空出来了，然后你放了2。
3. 如果第三张牌是4，你会先从第二个位置比较，第二个位置上现在是5，5是大于4的。因此，你会将5，移动到第三个位置。现在第二个位置左边的是2，2小于4，不用移动。所以把4放在第二个位置。
4. 这一次，你得到一张10。这比手上的所有的牌都要大。你会把它直接放在末尾。
5. 又抽到一张7。把10从原先的位置移开，插入7.
6. 假设抽到的最后一张是3，你先把10移动到右边，因为10大于3。然后你在检查左边的牌，左边是7，7也大于3，再把7移动到右边。同样5，4也经历同样的过程。最后3放在2的右边，因为2小于3。

恭喜你，抽到了同花顺，同花顺就这样排序完成了。

### JavaScript代码实现插入排序（Insertion Sort）

```

function InsertionSort(arr) {
    for(var i = 1; i < arr.length; i++) {
        var insertion = arr[i];
        var j = i - 1;
        while(j >= 0 && arr[j] > insertion) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = insertion;
    }
    return arr;
}

var arr = [9,6,3] // [6,9,3] => [3,6,9]
```

未完待续