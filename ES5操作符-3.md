gi# 操作符-3

---
前言：最近在细读Javascript高级程序设计，对于我而言，中文版，书中很多地方一笔带过，所以用自己所理解的，尝试细致解读下。如有纰漏或错误，会非常感谢您的指出。文中绝大部分内容引用自《JavaScript高级程序设计第三版》。

---

## 布尔操作符

在一门编程语言中，布尔操作符的重要性堪比相等操作符。**如果没有测试两个值关系的能力，那么诸如if...else和循环之类的语句就不会有用武之地了。**

**布尔操作符一共有3个：非（NOT)、与（AND）和或（OR）。**

1. 逻辑非

逻辑非操作符由一个叹号（!）表示，**可以应用于ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。**逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再将其求反。也就是说，逻辑非操作符遵循下列规则：

- 如果操作数是一个对象，返回false。

- 如果操作数是一个空字符串，返回true。

- 如果操作数是一个非空字符串，返回false。

- 如果操作数是数值0， 返回true。

- 如果操作数是任意非0数值（包括Infinity），返回false。

- 如果操作数是null，返回true。

- 如果操作数是NaN，返回true。

- 如果操作数是undefined，返回true。

```

console.log(!false); //true

console.log(!"blue"); //false

console.log(!0); //true

console.log(!NaN); //true

console.log(!""); //true

console.log(!12345); //false

```

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。

```
console.log(!!"blue"); //true

console.log(!!0); //false

console.log(!!NaN); //false

console.log(!!""); //false

console.log(!!1234); //true
```

2. 逻辑与

逻辑与操作符由两个和号(&&)表示，有两个操作符。

```
var result = true && false; //false;

console.log(result);

```

逻辑与的真值表

|第一个操作数|第二个操作数|结果|
|:-:|:-:|:-:|
|true|true|true|
|true|false|false|
|false|true|false|
|false|false|false|

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。

- 如果第一个操作数是对象，则返回第二个操作数。
  
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象。

- 如果两个操作数都是对象，则返回第二个操作数。

- 如果第一个操作数是null，则返回null。

- 如果第一个操作数是NaN，则返回NaN。

- 如果第一个操作数是undefined，则返回undefined。

**逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。**就是说，如果第一个操作数是false，无论第二个操作数是什么值，结果都不再可能是true了。

```
var found = true;

var result = (found && someUndefinedVariable);  //Referenceerror, someUndefinedVariable is not defined.

console.log(result); 
```

在上面的代码中，当执行逻辑与操作时会发生错误，因为变量someUndefinedVariable没有声明。
由于变量found的值是true，所以逻辑与操作符会继续对变量someUndefinedVariable求值。
而someUndefinedVariable没有定义，就导致了错误。

**如果像下面这个例子中一样，将found的值设置为false，就不会发生错误了。**

```
var found =  false; 
var result = (found && someUndefinedVariable);  //不会发生错误

console.log(result);// false;
```

在这个例子中，控制台会打印出false。无论变量someUndefinedVariable有没有定义，也永远不会对它求值，因为第一个操作数的值是false。这也意味着逻辑与操作的结果必定是false，用不着再对&&右侧的操作数求值了。

**在使用逻辑与操作符时要始终铭记它是一个短路操作符。**

3. 逻辑或

逻辑或操作符由两个竖线符号（||）表示，有两个操作数。

```
var result = true || false;
```

逻辑或的真值表

|第一个操作数|第二个操作数|结果|
|true|true|true|
|true|false|true|
|false|true|true|
|false|false|false|

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。

- 如果第一个操作数是对象，则返回第一个操作数。

- 如果第一个操作数的求值结果为false，则返回第二个操作数。

- 如果两个操作数都是对象，则返回第一个操作数。

- 如果两个操作数都是null，则返回null。

- 如果两个操作数都是NaN，则返回NaN。

- 如果两个操作数都是undefined，则返回undefined。

**与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果是true，就不会对第二个操作数求值了。**

```
var found = true;

var result = (found || someUndefinedVariable); //true

console.log(result); //true
```

这个例子跟前面的例子一样，变量someUndefinedVariable也没有定义。但是，由于变量found的值是true，而变量someUndefinedVariable永远不会被求值，因此结果就会输出“true”。

如果像下面这个例子一样，把found的值改为false，就会导致错误。

```

var found = false;

var result = (found || someUndefinedVariable); //Reference Error, someUndefinedVariable is not defined.

console.log(result); 

```

**可以利用逻辑或的这一行为来避免为变量赋null或undefined值。**

```
var myObject = preferredObject || backupObject;
```

在这个例子中，变量myObject将被赋予等号后面两个值中的一个。变量preferredObject中包含优先赋给myObject的值，变量backupObject负责在preferredObject中不包含有效值的情况下提供后背值。如果preferredObject的值不是null，那么它的值将被赋给myObject。如果是null，则将backupObject的值赋给myObject。

ECMAScript程序的赋值语句经常会使用这种模式。

## 乘性操作符

ECMAScript定义了3个乘性操作符：乘法、除法和求模。 这些操作符与Java、C或者Perl中的相应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串被当做0，布尔值true将被当做1。

1. 乘法

乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。

```
var result = 3 * 4; //12
```

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法算法，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有负号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity。

- 如果有一个操作数是NaN，则结果是NaN。
  
- 如果是Infinity与0相乘，则结果是NaN。

- 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号。

- 如果是Infinity与Infinity相乘，这结果是Infinity。

- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

2. 除法

除法操作符由一个斜杠号（/）表示，执行第一个操作数除第而个操作数的计算。

```
var result = 66 /11;

console.log(result); //6
```

与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。

- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有负号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity。

- 如果有一个操作数是NaN，则结果是NaN。

- 如果是Infinity被Infinity除，则结果是NaN。

- **如果是零被零除，则结果是NaN。**

- 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。

- 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。

- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

3. 求模

求模（余数）操作符由一个百分号（%）表示。

```
var result = 25 % 6; // 1
```

与另外两个乘性操作符类似，求模操作会遵循下列特殊规则来处理特殊的数值：

- 如果操作数都是数值，执行常规的除法运算，返回除得的余数。

- 如果除数是无穷大值而除数是有限大的数值，则结果是NaN。

- 如果除数是有限大的数值而被除数是零，则结果是NaN。

- 如果是Infinity被Infinity除，则结果是NaN。

- 如果被除数是无限大的数值而除数是有限大的数值，则结果是除数。

- 如果除数是零，则结果是零。

- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

## 加性操作符

加法与减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但在ECMAScript中这两个操作符却都有一系列的特殊行为。与乘法操作符类似，加性操作符也会在后台转换不同的数据类型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。

1. 加法

加法操作符（+）的用法如下：

```
var result = 1 + 2;

console.log(result); //3
```

如果操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

- 如果有一个操作数是NaN，则结果是NaN。

- 如果是Infinity加Infinity，则结果是Infinity。

- 如果是-Infinity加-Infinity，则结果是-Infinity。

- 如果是Infinity加-Infinity，则结果是NaN。

- 如果是+0 加 +0，则结果是 +0。

- 如果是-0 加 -0，则结果是 -0。

- 如果是+0 加 -0，则结果是 +0。

**不过，如果有一个操作数是字符串，那么就要应用如下规则：**

- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来。

- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

**如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。**

```
var result1 = 5 + 5;

console.log(result1); //10

var result2 = 5 + '5';

console.log(result2); //'55'
```

以上带代码演示了加法操作符在两种模式下的差别。第一行代码演示了正常的情况，即5+5等于10（数值）。但是，如果将一个操作数改为字符串“5”，结果就变成了“55（字符串值），因为第一个操作数也被转换成了“5”。

**忽略加法操作中的数据类型是ECMAScript变成中最常见的一个错误。**

```
var num1 = 5;
var num2 = 10;

var message = "The sum of 5 and 10 is " + num1 + num2; 

console.log(message); //"The sum of 5 and 10 is 510"
```

在这个例子中，变量message的值是执行两个加法操作之后的结果。
有人可能以为最后得到的字符串是“The sum of 5 and 10 is 15"，但实际的结果却是“The sum of 5 and 10 is 510”。

**之所以会这样，是因为每个加法操作是独立执行的。**第一个加法操作将一个字符串和一个数值（5）拼接起来，结果是一个字符串。而第二个加法操作又用这个字符串去加另一个数值（10），当然也会得到一个字符串。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用圆括号：

```
var num1 = 5;
var num2 = 10;

var message = "The sum of 5 and 10 is " + (num1 + num2); 

console.log(message); //"The sum of 5 and 10 is 15"
```

在这个例子中，**一对圆括号把两个数值变量括在了一起，这样就会告诉解析器先计算其结果。**然后再将结果与字符串拼接起来。因此，就得到了结果"The sum of 5 and 10 is 15"。

2.减法

减法操作符（-）是另一个极为常用的操作符。

```
var result = 2 - 1; 
console.log(result); //1
```

与加法操作符类似，ECMAScript中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则。

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；

- 如果有一个操作数是NaN，则结果是NaN；

- 如果是Infinity减Infinity，则结果是NaN；

- 如果是-Infinity减-Infinity，则结果是NaN；

- 如果是Infinity减-Infinity，则结果是Infinity；

- 如果是-Infinity减Infinity，则结果是-Infinity；

- 如果是+0加+0，则结果是+0；

- 如果是-0减+0，则结果是-0；

- 如果是-0减-0，则结果是+0；

- 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法操作。如果转换的结果是NaN，则减法的结果就是NaN。

- 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

```
var result = 5 - true; // 4，因为true被转换为了1

var result2 = NaN -1; //NaN

var result3 = 5 - 3; //2

var result4 = 5 - ""; //5，因为""被转换成了0

var result5 = 5 - "2"; //3，因为"2"被转换成了2

var result6 = 5 - null; //5, 因为Number(null)会被转化为0
```

## 关系操作符

小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于两个值进行比较，比较的规则与我们在数学课上所学的一样。**这几个操作符都返回一个布尔值。**

```
var result1 = 5 < 3; //true，返回一个布尔值

var result2 = 5 < 3; //flase， 返回一个布尔值
```

与ECMAScript中的其他操作符一样，当关系操作符的操作数使用非数值时，也要进行数据转换或完成某些奇怪的操作。

- 如果两个操作数都是数值，则执行数值比较。

- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。

- 如果一个操作数是数值，则将另一个操作符转换为一个数值，然后执行数值比较。

- 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则进行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。

- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

在使用关系符比较两个字符串时，会执行一种奇怪的操作。

很多人都会认为，在比较字符串时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际上完全不是那么回事。

**在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。**

经过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象：

```
var result = "Brick" < "alphabet"; //true
```

在这个例子中，字符串“Brick”被认为小于字符串“alphabet”。原因始字母B的字符编码为66，而字母a的字符编码是97。**如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的 大小写形式（全部大写或全部小写），然后再执行比较。**

```
var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); //false
```

通过将两个操作数都转换为小写形式，就可以得出"alphabet"按字母表顺序排在“Brick”之前的正确判断了。

另一种奇怪的现象发生在比较两个数字字符串的情况下。

```
var result = "23" < "3"; //true
```

确实，当比较字符串“23”是否小于“3”时，结果居然是true。
因为两个操作数都是字符串，而字符串比较的是字符串编码（“2”的字符编码是50，而“3”的字符编码是51）。不过，如果像下面例子中一样，将一个操作数改为数值，比较的结果就正常了。

```
var result = "23" < 3; //false
```

此时，字符串“23”会被转换数值23，然后再与3进行比较，因此就会得到合理的结果。
在比较数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。
当然，这个规则对前面的例子是适用的。**可是，如果那个字符串不能被转换成一个合理的数值呢？**

```
var result = "a" < 3; //false, 因为Number("a")，被转换为NaN
```

由于字母"a"不能转换成合理的数值，因此就被转换成了NaN。**根据规则，任何操作数与NaN进行关系比较，结果都是false。**

```

var result1 = NaN < 3; //false

var result2 = NaN >= 3; //false
```

按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。
**然而，在与NaN进行比较时，这两个比较操作的结果都返回了false。**


## 相等操作符

**确定两个变量是否相等是变成中的一个非常重要的操作。**

在比较字符串、数值和布尔值的相等性时，问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的ECMAScript中的相等和不等操作符会在执行比较之前，先将对象和转换成相似的类型。

后来，有人提出了这种转化到底是否合理的质疑。

最后，ECMAScript的解决方案就是提供两组操作符：相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。

1. 相等和不相等

ECMAScript中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回true。而不相等操作符由叹号等于号（!=）表示，如果两个操作数不相等，则返回true。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；

- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值。

- 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较。

**这两个操作符在进行比较时则要遵循下列规则**

- null和undefined是相等的。

- 要比较相等性之前，不能将null和undefined转换成其他任何值。

- 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。**即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。

- **如果两个操作数都是对象，则比较它们是不是同一个对象。**如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

|表达式|值|
|:-:|:-:|
|null == undefined|true|
|"NaN" == NaN| false|
|5 == NaN| false|
|NaN == NaN| false| 
|NaN != NaN| true|
|false == 0| true|
|true == 1| true|
|true == 2| false|
|undefined == 0 | false|
|null == 0|| false|
|"5" == 5| true|

2. 全等和不全等

除了在比较值钱不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。

等操作符由3个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回true。

```

var result1 = ("55" == 55); //true，因为转换后相等

var result2 = ("55" === 55); //false，因为不同的数据类型不相等

```

在这个例子中，第一个比较使用的是相等操作符比较字符串“55”和数值55，结果返回了true。

这是因为字符串“55”先被转换成了数值55，然后再与另一个数值55进行比较。
第二个比较使用了全等操作符以不转换数值的方式比较同样的字符串和值。
在不转换的情况下，字符串当然不等于数值，因此结果就是false。

不全等操作符由一个叹号后跟两个等于号（!==）表示，它在两个操作数未经转换就不相等的情况下返回true。

```
var result1 = ("55" != 55); //false，因为转换后相等
var result2 = ("55" !== 55); //true，因为不同的数据类型不相等
```

在这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串“55”转换为55，结果就与第二个操作数（也是55）相等了，由于这两个操作数被认为相等，因此返回了false。第二个使用比较了不全等操作符。假如我们这样想：字符串55与数值55不相同吗？答案是：是的（true）。

**记住：null == undefined会返回true，因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。**


**由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。**

## 条件操作符

条件操作符应该算是ECMAScript中最灵活的一种操作符了，而且它遵循与Java中的条件操作符相同的语法形式。

```
variable = boolean_expression ? true_value : false_value;
```

本质上，这行代码的含义就是基于对boolean_exression求值的结果，决定给变量variable赋什么值。
如果求值结果为true，则给变量variable赋true_value值；如果求值结果为false，则给变量variable赋false_value值。

```
var max = (num1 > num2) ? num1 : num2;

```

在这个例子中，max中将会保存一个最大的值。这个表达式的意思是：如果num1大于num2（关系表达式返回true），则将num1的值赋给max；如果num1小于或等于num2（关系表达式返回false），则将num2的值赋给max。

## 赋值操作符

**简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量。**

```
var num = 10;
```

**如果在赋值操作符前面添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。**
这种复合赋值操作相当于是对下面常规表达式的简写形式。

```
var num = 10;

num = num + 10;

```

其中的第二行代码可以用一个复合赋值来代替：

```
var num = 10;

num += 10;
```

每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。

- 乘/赋值（*=）；
  
- 除/赋值（/=）;

- 模/赋值（%=）；

- 加/赋值（+=）； 

- 减/赋值（-=）；

- 左移/赋值 (<<=);

- 有符号右移/赋值（>>=）；

- 无符号右移/赋值（>>>=）；

**设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。**

## 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作。

```
var num1 = 1, num2 = 2, num3 = 3;
```

逗号操作符多用于声明多个变量，但除此之外，逗号操作符还可以用于赋值。
在用于赋值时，逗号操作符总会返回表达式中的最后一项。

```
var num = (0, 1, 3, 5, 8);

console.log(num); //8
```

由于8是表达式中的最后一项，因此num的值就是8。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。